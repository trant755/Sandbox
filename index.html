<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <style>
      body {
        background-color: #333;
      }
      .wrapper {
        margin: 0 auto;
        position: relative;
        width: 90vw;
        height: 80vh;
        background-color: #1f72f9;
        border-radius: 20px;
        overflow: hidden;
      }

      .container {
        position: absolute;
        right: 10%;
        top: 10%;
        background-color: transparent;
        width: 500px;
        height: 400px;
      }

      .svg-background {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        overflow: visible;
      }

      .content {
        position: relative;
        z-index: 1; /* Чтобы контент был поверх SVG */
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100%;
      }

      .pre-order-button {
        background-color: transparent;
        border: 1px solid #fff;
        border-radius: 20px;
        color: white;
        padding: 5px 15px;
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 5px;
      }
    </style>
    <div class="wrapper">
      <div id="draggable" class="container">
        <svg
          class="responsive-svg svg-background"
          xmlns="http://www.w3.org/2000/svg"
          id="mySVG"
        >
          <path id="dynamicPath" d="" fill="#333" />
        </svg>
        <div class="content">
          <button class="pre-order-button">PRE-ORDER <span>⚙️</span></button>
        </div>
      </div>
    </div>
    <button type="button" id="changeSize">Change size</button>
    <script>
      // Получаем размеры контейнера
      const wrapper = document.querySelector(".wrapper");

      function updatePath(left, top) {
        const container = document.querySelector(".container");
        const wrapperWidth = wrapper.offsetWidth;
        const wrapperHeight = wrapper.offsetHeight;
        const width = container.offsetWidth;
        const height = container.offsetHeight;
        const right = wrapperWidth - width - left;
        const bottom = wrapperHeight - height - top;

        // Пример вычисления нового пути на основе ширины и высоты
        const newPath = `
        M ${width / 2} 0
        L ${top < 2 ? width + 20 : width - 20} 0
        Q ${width} 0 ${width} ${right < 2 ? -20 : 20}
        L ${width} ${right < 2 ? height + 20 : height - 20}
        Q ${width} ${height} ${bottom < 2 ? width + 20 : width - 20} ${height}
        L ${bottom < 2 ? -20 : 20} ${height}
        Q 0 ${height} 0 ${left < 2 ? height + 20 : height - 20}
        L 0 ${left < 2 ? -20 : 20}
        Q 0 0 ${top < 2 ? -20 : 20} 0
      `;

        // Применяем новый путь к SVG
        document.getElementById("dynamicPath").setAttribute("d", newPath);
      }

      // Обновляем путь при загрузке и изменении размеров окна
      window.addEventListener("load", updatePath);
      window.addEventListener("resize", updatePath);

      //////////////////////////////////////////
      //
      /////////////////////////////////////////

      const draggable = document.getElementById("draggable");

      let isDragging = false;
      let offsetX, offsetY;

      draggable.addEventListener("mousedown", (event) => {
        isDragging = true;
        offsetX = event.clientX - draggable.offsetLeft;
        offsetY = event.clientY - draggable.offsetTop;
        draggable.style.cursor = "grabbing";
      });

      document.addEventListener("mousemove", (event) => {
        if (isDragging) {
          // Новые координаты элемента с учётом смещения курсора
          let newLeft = event.clientX - offsetX;
          let newTop = event.clientY - offsetY;

          // Границы контейнера
          const wrapperRect = wrapper.getBoundingClientRect();
          const draggableRect = draggable.getBoundingClientRect();

          // Проверяем и ограничиваем координаты в пределах контейнера
          if (newLeft < 0) newLeft = 0;
          if (newTop < 0) newTop = 0;
          if (newLeft + draggableRect.width > wrapperRect.width) {
            newLeft = wrapperRect.width - draggableRect.width;
          }
          if (newTop + draggableRect.height > wrapperRect.height) {
            newTop = wrapperRect.height - draggableRect.height;
          }

          // Устанавливаем новые координаты
          draggable.style.left = `${newLeft}px`;
          draggable.style.top = `${newTop}px`;
          updatePath(newLeft, newTop);
        }
      });

      document.addEventListener("mouseup", () => {
        isDragging = false;
        draggable.style.cursor = "grab";
      });

      const changeSizeButton = document.getElementById("changeSize");
      changeSizeButton.addEventListener("click", () => {
        const randomSize = [
          [300, 200],
          [400, 300],
          [500, 200],
          [200, 500],
        ][Math.floor(Math.random() * 3)];
        const container = document.querySelector(".container");
        container.style.width = `${randomSize[0]}px`;
        container.style.height = `${randomSize[1]}px`;
        updatePath();
      });
    </script>
  </body>
</html>
